use hax_lib as hax;

/// Values having this type hold a representative 'x' of the Kyber field.
/// We use 'fe' as a shorthand for this type.
pub(crate) type FieldElement = i32;

const BARRETT_SHIFT: i64 = 26;
const BARRETT_R: i64 = 0x4000000; // 2^26

/// This is calculated as ⌊(BARRETT_R / FIELD_MODULUS) + 1/2⌋
const BARRETT_MULTIPLIER: i64 = 20159;

pub(crate) const FIELD_MODULUS: i32 = 3329;

#[derive(Clone, Copy)]
pub struct Bounded<const MIN: i128, const MAX: i128>(pub i32);

#[hax::attributes]
impl<const MIN: i128, const MAX: i128> From<i32> for Bounded<MIN, MAX> {
    #[requires(x as i128 >= MIN && x as i128 <= MAX)]
    fn from(x: i32) -> Self {
        hax::debug_assert!(x as i128 >= MIN && x as i128 <= MAX);
        Self(x)
    }
}

impl<const MIN: i128, const MAX: i128> Bounded<MIN, MAX> {
    fn get_value(self) -> i32 {
        self.0
    }
}

// TODO: in the F* backend, translate `IsRefinement::refine x`/`IsRefinement::value x` as `x <: t_RefinedType` or `x <: t_InnerType`!
pub trait IsRefinement {
    type InnerType;
    fn refine(x: Self::InnerType) -> Self;
    fn value(self) -> Self::InnerType;
}

#[allow(non_snake_case)]
mod __hax__autogenerated_refinement__Refinement {
    use super::*;
    // #[hax::newtype_as_refinement(|x| x > 23)]
    pub struct Refinement(u8);
    #[hax::exclude]
    impl super::IsRefinement for Refinement {
        type InnerType = u8;
        fn refine(x: Self::InnerType) -> Self {
            Self(x)
        }
        fn value(self) -> Self::InnerType {
            self.0
        }
    }
    // impl From<u8> for Refinement {
    //     fn from(x: u8) -> Self {
    //         Refinement(x)
    //     }
    // }
    // impl Refinement {
    //     pub fn inner(x: Self) -> u8 {
    //         x.0
    //     }
    // }
}
use __hax__autogenerated_refinement__Refinement::*;

// fn xx() {
//     let _ = Refinement::from(3);
// }

// macro_rules!  {

// }

/// Signed Barrett Reduction
///
/// Given an input `value`, `barrett_reduce` outputs a representative `result`
/// such that:
///
/// - result ≡ value (mod FIELD_MODULUS)
/// - the absolute value of `result` is bound as follows:
///
/// `|result| ≤ FIELD_MODULUS / 2 · (|value|/BARRETT_R + 1)
///
/// In particular, if `|value| < BARRETT_R`, then `|result| < FIELD_MODULUS`.
// #[hax::requires((i64::from(value) >= -BARRETT_R && i64::from(value) <= BARRETT_R))]
// #[hax::ensures(|result| //result > -FIELD_MODULUS && result < FIELD_MODULUS &&
//                    result % FIELD_MODULUS == value % FIELD_MODULUS)]
pub fn barrett_reduce(value: Bounded<{ -0x4000000 }, 0x4000000>) -> Bounded<{ -3328 }, 3328> {
    let t = i64::from(value.get_value()) * BARRETT_MULTIPLIER;
    // assert!(9223372036854775807 - (BARRETT_R >> 1) > t);
    let t = t + (BARRETT_R >> 1);

    let quotient = t >> BARRETT_SHIFT;
    // assert!(quotient <= 2147483647_i64 || quotient >= -2147483648_i64);
    let quotient = quotient as i32;

    // assert!(((quotient as i64) * (FIELD_MODULUS as i64)) < 9223372036854775807);
    let sub = quotient * FIELD_MODULUS;

    hax::fstar!(r"Math.Lemmas.cancel_mul_mod (v $quotient) 3329");

    Bounded::from(value.get_value() - sub)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        fn test(val: FieldElement, expected: FieldElement) {
            let reduced = barrett_reduce(val);
            assert_eq!(reduced, expected);
        }

        test(FIELD_MODULUS + 1, 1);
        test(FIELD_MODULUS, 0);
        test(FIELD_MODULUS - 1, -1);

        test(FIELD_MODULUS + (FIELD_MODULUS - 1), -1);
        test(FIELD_MODULUS + (FIELD_MODULUS + 1), 1);

        test(1234, 1234);
        test(9876, -111);

        test(4327, 4327 % FIELD_MODULUS)
    }
}
